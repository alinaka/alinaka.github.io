---
layout: post
permalink: "/git-intro"
title: "Знакомлюсь ближе с git"
date: 2019-09-15 15:24:52 +0300
categories: git
---
Довольно давно я пользовалось гитом на очень базовом уровне, и вполне себе нормально работала. Те основные команды, которые я знала и которыми я пользовалась:
- add 
- commit 
- checkout
- branch
- reset
- pull
- push
- merge
	
В гите много других возможностей, которые позволяют делать много крутых штук.
Сегодня я опишу некоторые из них.

Например, `git cherry-pick`.
Эта команда позволяет перенести один коммит из одной ветки в другую (ну или несколько коммитов тоже можно).
Допустим, вы сейчас находитесь на ветке master, и хотите из соседней ветки hotfix перенести только один коммит.
`git cherry-pick <hash>`, где `<hash>` - это хэш коммита, который вы хотите себе утащить. 
Либо если вы хотите несколько коммитов - то можно так: `git cherry-pick <hash1> <hash2>`.

Или есть еще такая классная команда `rebase`. О ней обычно говорят в сравнении с `merge`. Есть два способа слить две ветки:
это всем известный `merge`, который по сути просто сливает их в одну, и создает merge commit, у которого родителями становятся два последних коммита с каждой ветки.
На картинке это может выглядеть так:
![merging branches](https://git-scm.com/book/en/v2/images/basic-rebase-2.png)

Есть также другой способ смержить две ветки - это `rebase`.
Допустим, у вас есть ветка master, и в какой-то момент от нее ответвился experiment.
После это в master были еще коммиты, но насталo время влить свой experiment.
Тогда, находясь на ветке experiment, можно сделать `git rebase master`, и тогда ваши коммиты применятся 'поверх' последнего коммита в master. 
Такого же эффекта можно достичь, если находясь на другой ветке сделать `git rebase master experiment`.
История ветки теперь будет выглядеть так, будто вы только что ответвились от master, и после этого сделали все свои коммиты в experiment.
![merging branches](https://git-scm.com/book/en/v2/images/basic-rebase-3.png)
Конечно, изменения эти будут только в ветке experiment. Чтобы их влить в master, нужно сделать `checkout` на master и там уже вызвать `git merge experiment`.

Rebase также можно использовать, допустим, еще в случае наличия трех веток, 
например, ветка side1 ответвилась от master, а от side1 в какой-то момент ответвилась side2. 
И во все эти ветки параллельно вносились изменения. И теперь вы хотите влить изменения с side2 в master,
при это не вливая изменения, которые есть в side1. 
Это можно сделать находясь на любой ветке, командой `git rebase --onto master side1 side2` - 
то есть: взять все изменения ветки side2, которых нет в side1, и перенести в master.
После этого side2 можно вливать в master обычным `merge`.

Также командой `rebase` можно изменять коммиты, которые оказались где-нибудь далеко в истории. 
Например, хотим сделать `git commit --amend`, но не для последнего коммита,
а для любого, который потребуется. Или для любых. 
Это можно сделать командой rebase с флагом -i - интерактивно.
Для этого надо будет вспомнить, как перемещаться по дереву git, я, если честно, это даже не знала.

`~` - переместиться вверх по иерархии на одно поколение

`~3` - переместиться вверх по иерархии на три поколения

`^` - переместиться вверх к родителю

`^2` - переместиться вверх ко второму родителю (в случае коммитов с несколькими родителями)

Итак, допустим, мы хотим изменить третий коммит, который находится от нашей текущей позиции.
Делаем `git rebase -i HEAD ~3`.
И получаем вот такое вот окно редактора.
![Git rebase -i](/assets/img/git-rebase-i.png)
Выбираем вариант который нам подходит вместо `pick`, например, `edit`.
Сохраняем, выходим из редактора, git в этот момент будет заново "применять"
эти коммиты, и остановится перед тем коммитом, который мы пометили на редактирование. 
Вносим изменения, набираем `git commit --amend`, можем поменять сообщение к коммиту,
далее набираем `git rebase --continue` для продолжение процесса `rebase`.
Также вместо edit, в редакторе мы могли бы поменять местами эти коммиты, или удалить какой-нибудь из них, 
или сквошнуть коммиты (из нескольких коммитов сделать один), в общем, вариантов много.

Для отмены коммита также можно использовать команду `git revert`. При этом нужно, чтобы не было изменений в рабочем дереве и в индексе ничего не было
с момента последнего коммита. Этой команде передается коммит(ы), которые нужно отменить, и по умолчанию она создает новый коммит с отмененными изменениями
(при передаче флага -n (--no-commit) коммита не будет, изменения будут только в рабочем дереве и в индексе).
Например, `git revert HEAD~3` отменить коммит, находящийся на три позиции позади текущей позиции HEAD.
`git revert -n master~5..master~3` - отмена изменений, начиная с пятого с конца коммита в master, до третьего (включительно).
Не будет создано нового коммита, т.к. передан флаг -n.

Еще пара интересных команд, о существовании которых я не знала.

`git blame` - показывает информацию о том, кто вносил последние изменения
в каждую строчку файла, название которого передается в качестве аргумента.

`git bisect` - найти с помощью двоичного поиска коммит, в котором появился баг.

`git describe` - показывает самый последний тэг, который доступен с коммита. Выведет что-то типа `v1.0.4-g2414721` - где `v1.0.4` -
это название тега, а `2414721` - это начало хэша текущего коммита.

Есть еще классные игры по знакомству с командами git:
- [git-game](https://github.com/git-game/git-game)
- [git-game-v2](https://github.com/git-game/git-game-v2)
- [Learn git branching](https://learngitbranching.js.org)

И самое главное, это, конечно, [документация](https://git-scm.com/doc),
и книжка [ProGit](https://git-scm.com/book).
